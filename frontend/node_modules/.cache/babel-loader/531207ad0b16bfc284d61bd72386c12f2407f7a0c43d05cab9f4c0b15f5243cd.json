{"ast":null,"code":"\"use client\";\n\n// src/useBaseQuery.ts\nimport * as React from \"react\";\nimport { notifyManager } from \"@tanstack/query-core\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport { ensurePreventErrorBoundaryRetry, getHasError, useClearResetErrorBoundary } from \"./errorBoundaryUtils.js\";\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend } from \"./suspense.js\";\nfunction useBaseQuery(options, Observer, queryClient) {\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = client.defaultQueryOptions(options);\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureStaleTime(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(() => new Observer(client, defaultedOptions));\n  const result = observer.getOptimisticResult(defaultedOptions);\n  React.useSyncExternalStore(React.useCallback(onStoreChange => {\n    const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));\n    observer.updateResult();\n    return unsubscribe;\n  }, [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]);\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query: observer.getCurrentQuery()\n  })) {\n    throw result.error;\n  }\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport { useBaseQuery };","map":{"version":3,"names":["React","notifyManager","useQueryErrorResetBoundary","useQueryClient","useIsRestoring","ensurePreventErrorBoundaryRetry","getHasError","useClearResetErrorBoundary","ensureStaleTime","fetchOptimistic","shouldSuspend","useBaseQuery","options","Observer","queryClient","client","isRestoring","errorResetBoundary","defaultedOptions","defaultQueryOptions","_optimisticResults","observer","useState","result","getOptimisticResult","useSyncExternalStore","useCallback","onStoreChange","unsubscribe","subscribe","batchCalls","updateResult","getCurrentResult","useEffect","setOptions","listeners","throwOnError","query","getCurrentQuery","error","notifyOnChangeProps","trackResult"],"sources":["/Users/mac/Desktop/FORESE/DB_Software/frontend/node_modules/@tanstack/react-query/src/useBaseQuery.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport { notifyManager } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend } from './suspense'\nimport type { UseBaseQueryOptions } from './types'\nimport type { QueryClient, QueryKey, QueryObserver } from '@tanstack/query-core'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n) {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange))\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n"],"mappings":";;;AACA,YAAYA,KAAA,MAAW;AAEvB,SAASC,aAAA,QAAqB;AAC9B,SAASC,0BAAA,QAAkC;AAC3C,SAASC,cAAA,QAAsB;AAC/B,SAASC,cAAA,QAAsB;AAC/B,SACEC,+BAAA,EACAC,WAAA,EACAC,0BAAA,QACK;AACP,SAASC,eAAA,EAAiBC,eAAA,EAAiBC,aAAA,QAAqB;AAIzD,SAASC,aAOdC,OAAA,EAOAC,QAAA,EACAC,WAAA,EACA;EACA,MAAMC,MAAA,GAASZ,cAAA,CAAeW,WAAW;EACzC,MAAME,WAAA,GAAcZ,cAAA,CAAe;EACnC,MAAMa,kBAAA,GAAqBf,0BAAA,CAA2B;EACtD,MAAMgB,gBAAA,GAAmBH,MAAA,CAAOI,mBAAA,CAAoBP,OAAO;EAG3DM,gBAAA,CAAiBE,kBAAA,GAAqBJ,WAAA,GAClC,gBACA;EAEJR,eAAA,CAAgBU,gBAAgB;EAChCb,+BAAA,CAAgCa,gBAAA,EAAkBD,kBAAkB;EAEpEV,0BAAA,CAA2BU,kBAAkB;EAE7C,MAAM,CAACI,QAAQ,IAAUrB,KAAA,CAAAsB,QAAA,CACvB,MACE,IAAIT,QAAA,CACFE,MAAA,EACAG,gBACF,CACJ;EAEA,MAAMK,MAAA,GAASF,QAAA,CAASG,mBAAA,CAAoBN,gBAAgB;EAEtDlB,KAAA,CAAAyB,oBAAA,CACEzB,KAAA,CAAA0B,WAAA,CACHC,aAAA,IAAkB;IACjB,MAAMC,WAAA,GAAcZ,WAAA,GAChB,MAAM,SACNK,QAAA,CAASQ,SAAA,CAAU5B,aAAA,CAAc6B,UAAA,CAAWH,aAAa,CAAC;IAI9DN,QAAA,CAASU,YAAA,CAAa;IAEtB,OAAOH,WAAA;EACT,GACA,CAACP,QAAA,EAAUL,WAAW,CACxB,GACA,MAAMK,QAAA,CAASW,gBAAA,CAAiB,GAChC,MAAMX,QAAA,CAASW,gBAAA,CAAiB,CAClC;EAEMhC,KAAA,CAAAiC,SAAA,CAAU,MAAM;IAGpBZ,QAAA,CAASa,UAAA,CAAWhB,gBAAA,EAAkB;MAAEiB,SAAA,EAAW;IAAM,CAAC;EAC5D,GAAG,CAACjB,gBAAA,EAAkBG,QAAQ,CAAC;EAG/B,IAAIX,aAAA,CAAcQ,gBAAA,EAAkBK,MAAA,EAAQP,WAAW,GAAG;IACxD,MAAMP,eAAA,CAAgBS,gBAAA,EAAkBG,QAAA,EAAUJ,kBAAkB;EACtE;EAGA,IACEX,WAAA,CAAY;IACViB,MAAA;IACAN,kBAAA;IACAmB,YAAA,EAAclB,gBAAA,CAAiBkB,YAAA;IAC/BC,KAAA,EAAOhB,QAAA,CAASiB,eAAA,CAAgB;EAClC,CAAC,GACD;IACA,MAAMf,MAAA,CAAOgB,KAAA;EACf;EAGA,OAAO,CAACrB,gBAAA,CAAiBsB,mBAAA,GACrBnB,QAAA,CAASoB,WAAA,CAAYlB,MAAM,IAC3BA,MAAA;AACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}